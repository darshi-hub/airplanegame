<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON ACE: Vector Assault</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', sans-serif; /* Sci-fi font */
            user-select: none;
        }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at center, #1a0033 0%, #000000 100%); }
        
        /* UI Styles */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; }
        .hud-text { color: #00ffff; text-shadow: 0 0 10px #00ffff, 2px 2px 0 #000; font-size: 24px; font-weight: bold; letter-spacing: 2px; }
        #score-display { position: absolute; top: 20px; left: 20px; }
        
        #health-bar-container { position: absolute; top: 20px; right: 20px; width: 250px; height: 25px; 
            background: rgba(0,0,0,0.8); border: 2px solid #00ffff; transform: skewX(-20deg); overflow: hidden; box-shadow: 0 0 15px #00ffff; }
        #health-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff00ff, #00ffff); transition: width 0.2s ease-out; }

        #controls-hint { position: absolute; bottom: 20px; width: 100%; text-align: center; color: rgba(255,255,255,0.7); font-size: 14px; text-transform: uppercase; letter-spacing: 3px; pointer-events: none;}
        .highlight { color: #00ff00; font-weight: bold; }

        /* Screens */
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            align-items: center; justify-content: center; pointer-events: auto; z-index: 10;
            backdrop-filter: blur(5px);
        }
        h1 { color: #fff; font-size: 70px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 10px;
             background: linear-gradient(to right, #ff00ff, #00ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
             filter: drop-shadow(0 0 20px rgba(0,255,255,0.5)); }
        p { color: #ccc; font-size: 20px; margin-bottom: 40px; letter-spacing: 2px; text-align: center;}
        
        button {
            padding: 20px 60px; font-size: 24px; font-family: 'Orbitron', sans-serif;
            background: transparent; border: 3px solid #00ffff; color: #00ffff;
            cursor: pointer; text-transform: uppercase; letter-spacing: 4px;
            position: relative; overflow: hidden; transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0,255,255,0.2);
        }
        button::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.5), transparent);
            transition: 0.5s;
        }
        button:hover { background: rgba(0,255,255,0.1); box-shadow: 0 0 40px rgba(0,255,255,0.6); }
        button:hover::before { left: 100%; }
        .hidden { display: none !important; }
    </style>
</head>

<body>

<div id="game-container"></div>

<div id="ui-layer">
    <div id="score-display" class="hud-text">SCORE: 0</div>
    <div id="health-bar-container"><div id="health-fill"></div></div>
    <div id="controls-hint">CLICK & DRAG to Draw Flight Path â€¢ Firing is Automatic</div>
</div>

<div id="start-screen">
    <h1>NEON ACE</h1>
    <p>Draw your destiny.<br>Survive the grid.</p>
    <button id="start-btn">INITIATE</button>
</div>

<div id="game-over-screen" class="hidden">
    <h1>SYSTEM FAILURE</h1>
    <p id="final-score">Score: 0</p>
    <button id="restart-btn">REBOOT</button>
</div>

<script type="module">

// ==================== IMPORTS ====================
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js";

// ==================== CONFIG ====================
const CONFIG = {
    playerSpeed: 0.35, // Speed at which plane follows path
    bulletSpeed: 3.0,
    fireRate: 150, // ms between shots
    enemySpeed: 0.7,
    spawnRateBase: 1200,
    colors: {
        grid: 0xff00ff,
        playerBody: 0x00aaff,
        playerEngine: 0x00ffff,
        enemyBody: 0xff3300,
        enemyEngine: 0xff9900,
        bullet: 0x00ff00,
        pathLine: 0x00ff00
    }
};

// ==================== GLOBALS ====================
let scene, camera, renderer, clock;
let player;
let bullets = [];
let enemies = [];
let particles = [];
let score = 0;
let playerHealth = 100;
let isGameRunning = false;
let lastShootTime = 0;
let nextSpawnTime = 0;
let currentSpawnRate = CONFIG.spawnRateBase;

// Drawing & Movement Control globals
let isDrawing = false;
let flightPathPoints = []; // The points the plane is currently following
let drawingPathPoints = []; // The points being drawn by mouse right now
let pathLineMesh = null; // The visual line for drawing
const raycaster = new THREE.Raycaster();
// Invisible plane at Z=0 for raycasting, adjusted for the tilted camera view
const drawingPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); 
const mouse = new THREE.Vector2();
let playerTrail = []; 

// DOM
const scoreEl = document.getElementById('score-display');
const healthFillEl = document.getElementById('health-fill');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const finalScoreEl = document.getElementById('final-score');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');


// ==================== INIT ====================
function init() {
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.015);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 300);
    camera.position.set(0, 15, 30); // Raised and slightly tilted view
    camera.lookAt(0, 0, -20);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('game-container').appendChild(renderer.domElement);

    // FIX: Stronger Directional Light for better model visibility
    const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
    dirLight.position.set(0, 20, 30);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4)); // So colors aren't totally black

    createEnvironment();
    initPathVisualization();

    window.addEventListener('resize', onWindowResize);
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
    document.addEventListener('touchstart', onTouchStart, {passive: false});
    document.addEventListener('touchmove', onTouchMove, {passive: false});
    document.addEventListener('touchend', onMouseUp);


    // FIX: Use touchstart on buttons for immediate responsiveness on mobile
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);
    
    startBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); startGame(); }, {passive: false});
    restartBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); startGame(); }, {passive: false});

    initGameObjects();
    animate();
}

function initGameObjects() {
    player = createSciFiShip(CONFIG.colors.playerBody, CONFIG.colors.playerEngine);
    player.position.set(0, 0, 0); // Ensure player starts centered
    scene.add(player);
    startScreen.classList.remove('hidden');
}

// ==================== GAME STATE CONTROL ====================
function startGame() {
    startScreen.classList.add('hidden');
    gameOverScreen.classList.add('hidden');
    resetGame();
    isGameRunning = true;
    clock.start();
}

function resetGame() {
    score = 0;
    playerHealth = 100;
    currentSpawnRate = CONFIG.spawnRateBase;
    updateUI();

    enemies.forEach(e => scene.remove(e.mesh));
    bullets.forEach(b => scene.remove(b.mesh));
    particles.forEach(p => scene.remove(p.mesh));
    enemies = [];
    bullets = [];
    particles = [];
    flightPathPoints = [];
    drawingPathPoints = [];
    updatePathVisuals();

    clearTrail();

    player.position.set(0, 0, 0);
    player.rotation.set(0, 0, 0);
    nextSpawnTime = clock.getElapsedTime() + 1.0;
}

function gameOver() {
    isGameRunning = false;
    gameOverScreen.classList.remove('hidden');
    finalScoreEl.innerText = `Score: ${score}`;
}

function updateUI() {
    scoreEl.innerText = `SCORE: ${score}`;
    healthFillEl.style.width = `${Math.max(0, playerHealth)}%`;
    if(playerHealth > 50) healthFillEl.style.background = 'linear-gradient(90deg, #ff00ff, #00ffff)';
    else if (playerHealth > 25) healthFillEl.style.background = 'linear-gradient(90deg, #ff9900, #ff3300)';
    else healthFillEl.style.background = 'linear-gradient(90deg, #ff0000, #990000)';
}

// ==================== ENVIRONMENT & VISUALS ====================
function createEnvironment() {
    // Grid Floor
    const gridHelper = new THREE.GridHelper(400, 40, CONFIG.colors.grid, CONFIG.colors.grid);
    gridHelper.position.y = 0;
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.3;
    scene.add(gridHelper);
    
    // Distant Stars
    const starGeo = new THREE.BufferGeometry();
    const starCount = 500;
    const posArray = new Float32Array(starCount * 3);
    for(let i=0; i<starCount*3; i++) {
        posArray[i] = (Math.random() - 0.5) * 400;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true, opacity: 0.6});
    const stars = new THREE.Points(starGeo, starMat);
    stars.position.z = -150;
    scene.add(stars);
}

function initPathVisualization() {
    const material = new THREE.LineBasicMaterial({
        color: CONFIG.colors.pathLine,
        linewidth: 2,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending 
    });
    const geometry = new THREE.BufferGeometry();
    pathLineMesh = new THREE.Line(geometry, material);
    pathLineMesh.frustumCulled = false; 
    scene.add(pathLineMesh);
}

function updatePathVisuals() {
    if (drawingPathPoints.length > 1) {
        const pointsArray = new Float32Array(drawingPathPoints.length * 3);
        for (let i = 0; i < drawingPathPoints.length; i++) {
            pointsArray[i * 3] = drawingPathPoints[i].x;
            pointsArray[i * 3 + 1] = drawingPathPoints[i].y;
            pointsArray[i * 3 + 2] = drawingPathPoints[i].z;
        }
        pathLineMesh.geometry.setAttribute('position', new THREE.BufferAttribute(pointsArray, 3));
        pathLineMesh.geometry.attributes.position.needsUpdate = true;
        pathLineMesh.visible = true;
    } else {
        pathLineMesh.visible = false;
    }
}

// ==================== SIMPLIFIED PROCEDURAL SHIP MODEL ====================
function createSciFiShip(bodyColor, engineColor) {
    const g = new THREE.Group();

    const bodyMat = new THREE.MeshPhongMaterial({ color: bodyColor, shininess: 100, flatShading: false });
    const engineMat = new THREE.MeshBasicMaterial({ color: engineColor, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.9 });

    // Main hull (simple cone)
    const hull = new THREE.Mesh(new THREE.ConeGeometry(1, 4, 8), bodyMat);
    hull.rotation.x = Math.PI / 2;
    g.add(hull);

    // Wings (simple boxes)
    const wingGeo = new THREE.BoxGeometry(6, 0.2, 1.5);
    const wings = new THREE.Mesh(wingGeo, bodyMat);
    wings.position.set(0, 0, 0.5);
    g.add(wings);

    // Tail Fin (vertical)
    const finGeo = new THREE.BoxGeometry(0.2, 1.5, 1);
    const fin = new THREE.Mesh(finGeo, bodyMat);
    fin.position.set(0, 0.7, 1.5);
    g.add(fin);

    // Engines & Glow (Cylinders at the back)
    const engineGeo = new THREE.CylinderGeometry(0.5, 0.5, 1, 8);
    const engineR = new THREE.Mesh(engineGeo, bodyMat);
    engineR.rotation.x = Math.PI / 2;
    engineR.position.set(1.5, 0, -1.8);
    g.add(engineR);
    const engineL = engineR.clone();
    engineL.position.x = -1.5;
    g.add(engineL);

    // Engine Glows (Cone pointing back)
    const glowGeo = new THREE.ConeGeometry(0.4, 1, 8);
    const glowMat = new THREE.MeshBasicMaterial({ color: engineColor, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.9 });
    
    const glowR = new THREE.Mesh(glowGeo, glowMat);
    glowR.rotation.x = -Math.PI/2;
    glowR.position.set(0, 0, -0.5);
    engineR.add(glowR); 
    
    const glowL = glowR.clone();
    engineL.add(glowL);

    return g;
}

// ==================== CONTROLS (DRAWING) ====================
function getMouseWorldPosition(clientX, clientY) {
    mouse.x = (clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = new THREE.Vector3();
    // Intersect the Z=0 plane (where the player lives)
    raycaster.ray.intersectPlane(drawingPlane, intersects);
    return intersects;
}

function onMouseDown(e) {
    if (!isGameRunning || e.target.tagName === 'BUTTON') return;
    isDrawing = true;
    flightPathPoints = []; // Clear existing path immediately on new click
    drawingPathPoints = []; 
    const pos = getMouseWorldPosition(e.clientX, e.clientY);
    
    // Start drawing from current player position
    drawingPathPoints.push(player.position.clone()); 
    // Add the first clicked point
    drawingPathPoints.push(pos);
    updatePathVisuals();
}

function onMouseMove(e) {
    if (!isGameRunning || !isDrawing) return;
    const pos = getMouseWorldPosition(e.clientX, e.clientY);
    
    if (drawingPathPoints.length > 0) {
        const lastPoint = drawingPathPoints[drawingPathPoints.length - 1];
        if (pos.distanceTo(lastPoint) > 1.0) { // Increased threshold for smoother drawing
            drawingPathPoints.push(pos);
            updatePathVisuals();
        }
    }
}

function onMouseUp() {
    if (!isGameRunning) return;
    isDrawing = false;
    // Transfer drawn points to the active flight path buffer
    if (drawingPathPoints.length > 1) {
        flightPathPoints = drawingPathPoints.slice(1); // Start path from the first drawn point, ignoring player.position
    }
    drawingPathPoints = []; 
    updatePathVisuals(); 
}

// Mobile Touch handlers
function onTouchStart(e) {
    // FIX: Check if the user touched a button. 
    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
        return; 
    }
    if(e.touches.length > 0) {
        // Use the first touch point
        onMouseDown(e.touches[0]); 
        e.preventDefault(); 
    }
}
function onTouchMove(e) {
    if(e.touches.length > 0) {
        onMouseMove(e.touches[0]);
        e.preventDefault();
    }
}


// ==================== GAME LOOP & LOGIC ====================
function animate() {
    requestAnimationFrame(animate);
    if (!isGameRunning) {
        renderer.render(scene, camera);
        return;
    }

    const time = clock.getElapsedTime();

    updatePlayerMovement();
    updateTrails();
    updateBullets();
    updateEnemies(time);
    updateParticles();
    handleAutoFire(time);

    renderer.render(scene, camera);
}

function updatePlayerMovement() {
    player.position.y = Math.sin(clock.elapsedTime * 2) * 0.2; // Keep the plane slightly moving up/down

    if (flightPathPoints.length > 0) {
        const target = flightPathPoints[0];
        const step = CONFIG.playerSpeed;
        
        const currentPos = player.position.clone();
        const dir = target.clone().sub(currentPos).normalize();
        
        const dist = currentPos.distanceTo(target);

        if (dist < step) {
             player.position.copy(target); // Snap to point
             flightPathPoints.shift();
        } else {
            player.position.add(dir.multiplyScalar(step));
            
            // Rotation based on movement direction
            const lookTarget = player.position.clone().add(dir.clone().multiplyScalar(5));
            const dummy = new THREE.Object3D();
            dummy.position.copy(player.position);
            dummy.lookAt(lookTarget);
            player.quaternion.slerp(dummy.quaternion, 0.15);

            // Banking (roll)
            const bankAmount = -dir.x * 0.5;
            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, bankAmount, 0.1);
        }
        
        if(frameCount % 3 === 0) createTrailSegment(player.position, player.rotation);
    } else {
         // Level out when stationary
         player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, 0, 0.1);
         player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, 0, 0.1);
    }
}

let frameCount = 0;

// ----- Player Trail Effect -----
function createTrailSegment(pos, rot) {
    const geo = new THREE.PlaneGeometry(3, 0.5);
    const mat = new THREE.MeshBasicMaterial({
        color: CONFIG.colors.playerEngine,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
    });
    const seg = new THREE.Mesh(geo, mat);
    seg.position.copy(pos);
    seg.rotation.copy(rot);
    seg.rotation.x = Math.PI/2; // Orient to lie flat
    seg.position.z += 0.5; // Offset slightly behind ship
    
    scene.add(seg);
    playerTrail.push({mesh: seg, life: 1.0});
}

function updateTrails() {
    frameCount++;
    for(let i = playerTrail.length - 1; i >= 0; i--) {
        let seg = playerTrail[i];
        seg.life -= 0.04;
        seg.mesh.material.opacity = seg.life * 0.6;
        seg.mesh.scale.x = seg.life; 
        if(seg.life <= 0) {
            scene.remove(seg.mesh);
            playerTrail.splice(i, 1);
        }
    }
}

function clearTrail() {
    playerTrail.forEach(t => scene.remove(t.mesh));
    playerTrail = [];
}
// -------------------------------


function handleAutoFire(time) {
    if (time * 1000 - lastShootTime > CONFIG.fireRate) {
        shoot();
        lastShootTime = time * 1000;
    }
}

function shoot() {
    const bulletGeo = new THREE.CapsuleGeometry(0.15, 0.8, 4, 8);
    const bulletMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.bullet, blending: THREE.AdditiveBlending });
    const bullet = new THREE.Mesh(bulletGeo, bulletMat);

    bullet.position.copy(player.position);
    bullet.rotation.copy(player.rotation); 
    bullet.rotateX(Math.PI / 2); 
    bullet.position.y += 0.2; 

    const forwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
    bullet.userData.velocity = forwardDir.multiplyScalar(CONFIG.bulletSpeed);

    scene.add(bullet);
    bullets.push({ mesh: bullet });
}


function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.add(b.userData.velocity);

        if (b.mesh.position.z < -200 || b.mesh.position.z > 50 || Math.abs(b.mesh.position.x) > 100) {
            scene.remove(b.mesh);
            bullets.splice(i, 1);
        }
    }
}

function updateEnemies(time) {
    // Spawning
    if (time > nextSpawnTime) {
        spawnEnemy();
        nextSpawnTime = time + currentSpawnRate / 1000;
        if (currentSpawnRate > 400) currentSpawnRate -= 15;
    }

    // Movement & Collision
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.mesh.position.z += CONFIG.enemySpeed;
        e.mesh.position.x += Math.sin(time * 2 + e.offset) * 0.1;

        // Player Collision
        if (e.mesh.position.distanceTo(player.position) < 3.0) {
            createExplosion(player.position, CONFIG.colors.playerEngine, 20);
            playerHealth -= 25;
            updateUI();
            scene.remove(e.mesh);
            enemies.splice(i, 1);
            if (playerHealth <= 0) gameOver();
            continue;
        }

        // Bullet Collision
        for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            if (b.mesh.position.distanceTo(e.mesh.position) < 3.0) {
                createExplosion(e.mesh.position, CONFIG.colors.enemyEngine, 15);
                scene.remove(b.mesh);
                bullets.splice(j, 1);
                scene.remove(e.mesh);
                enemies.splice(i, 1);
                score += 150;
                updateUI();
                break;
            }
        }

        // Cleanup missed enemies
        if (e.mesh.position.z > 30) {
             scene.remove(e.mesh);
             enemies.splice(i, 1);
        }
    }
}

function spawnEnemy() {
    const enemy = createSciFiShip(CONFIG.colors.enemyBody, CONFIG.colors.enemyEngine);
    enemy.position.set((Math.random()-0.5)*120, 0, -200);
    enemy.rotation.y = Math.PI; 
    enemy.scale.setScalar(1.2); 
    enemy.offset = Math.random() * 100; 
    scene.add(enemy);
    enemies.push({ mesh: enemy, offset: enemy.offset });
}

function createExplosion(pos, color, count) {
    for (let i = 0; i < count; i++) {
        const part = new THREE.Mesh(
            new THREE.TetrahedronGeometry(Math.random()*0.5 + 0.2),
            new THREE.MeshBasicMaterial({ color: color, blending: THREE.AdditiveBlending, transparent:true })
        );
        part.position.copy(pos);
        const vel = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(Math.random()*1.5);
        scene.add(part);
        particles.push({ mesh: part, velocity: vel, life: 1.0, rotSpeed: (Math.random()-0.5)*0.5 });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= 0.02;
        p.mesh.position.add(p.velocity);
        p.mesh.rotation.x += p.rotSpeed;
        p.mesh.rotation.y += p.rotSpeed;
        p.mesh.scale.setScalar(p.life);
        p.mesh.material.opacity = p.life;
        if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

init();

</script>
</body>
</html>
