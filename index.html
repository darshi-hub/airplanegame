<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON ACE: OVERDRIVE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Orbitron', sans-serif; user-select: none; }
        
        /* Vignette effect for style */
        body::after {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 150px rgba(0,0,0,0.9); pointer-events: none; z-index: 5;
        }

        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; z-index: 10; }
        
        .hud-text { 
            color: #fff; text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff; 
            font-size: 24px; font-weight: 900; letter-spacing: 2px;
            background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 4px; border: 1px solid rgba(0,255,255,0.3);
        }
        #score-display { position: absolute; top: 20px; left: 20px; }
        
        #health-bar-container { 
            position: absolute; top: 20px; right: 20px; width: 300px; height: 20px; 
            background: rgba(20,20,20,0.8); border: 1px solid #fff; 
            transform: skewX(-20deg); box-shadow: 0 0 15px rgba(0,255,255,0.3); 
        }
        #health-fill { 
            width: 100%; height: 100%; 
            background: linear-gradient(90deg, #ff00ff, #00ffff); 
            transition: width 0.2s cubic-bezier(0.1, 0.7, 1.0, 0.1);
            box-shadow: 0 0 20px #00ffff;
        }

        #controls-hint { 
            position: absolute; bottom: 30px; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.5); font-size: 12px; letter-spacing: 4px; pointer-events: none;
            text-shadow: 0 0 5px rgba(255,255,255,0.3);
        }

        /* Screens */
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: flex; flex-direction: column;
            align-items: center; justify-content: center; pointer-events: auto; z-index: 20;
            backdrop-filter: blur(8px);
        }
        
        h1 { 
            font-size: 80px; margin: 0; line-height: 1;
            background: linear-gradient(to bottom, #fff, #00ffff); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 30px rgba(0,255,255,0.8));
            font-weight: 900; font-style: italic;
        }
        p { color: #aaa; font-size: 18px; margin-top: 10px; margin-bottom: 50px; letter-spacing: 3px; text-transform: uppercase; }
        
        button {
            padding: 15px 50px; font-size: 20px; font-family: 'Orbitron', sans-serif; font-weight: bold;
            background: rgba(0,0,0,0.5); border: 2px solid #00ffff; color: #fff;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            transition: 0.3s; box-shadow: 0 0 15px rgba(0,255,255,0.2), inset 0 0 20px rgba(0,255,255,0.1);
        }
        button:hover { 
            background: #00ffff; color: #000; 
            box-shadow: 0 0 50px rgba(0,255,255,0.8);
        }
        .hidden { display: none !important; }
    </style>
</head>

<body>

<div id="game-container"></div>

<div id="ui-layer">
    <div id="score-display" class="hud-text">SCORE: 0</div>
    <div id="health-bar-container"><div id="health-fill"></div></div>
    <div id="controls-hint">DRAG TO FLY â€¢ AUTO-FIRE ACTIVE</div>
</div>

<div id="start-screen">
    <h1>NEON ACE</h1>
    <p>Draw path to survive</p>
    <button id="start-btn">ENGAGE SYSTEM</button>
</div>

<div id="game-over-screen" class="hidden">
    <h1>CRITICAL FAILURE</h1>
    <p id="final-score">Score: 0</p>
    <button id="restart-btn">REBOOT SYSTEM</button>
</div>

<script type="module">

// ==================== IMPORTS ====================
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js";
import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js";

// ==================== CONFIG ====================
const CONFIG = {
    playerSpeed: 0.45,
    bulletSpeed: 4.0,
    fireRate: 120, 
    enemySpeed: 0.9, 
    spawnRateBase: 1000,
    colors: {
        grid: 0xaa00aa,
        playerBody: 0x0088ff,
        playerEmissive: 0x0044aa,
        playerEngine: 0x00ffff,
        enemyBody: 0x222222,
        enemyEmissive: 0xff0000, // Bright red glow for visibility
        enemyEngine: 0xffaa00,
        bullet: 0x00ff00,
        pathLine: 0x00ffff
    }
};

// ==================== GLOBALS ====================
let scene, camera, renderer, composer, clock;
let player, grid;
let bullets = [];
let enemies = [];
let particles = [];
let score = 0;
let playerHealth = 100;
let isGameRunning = false;
let lastShootTime = 0;
let nextSpawnTime = 0;
let currentSpawnRate = CONFIG.spawnRateBase;

// Drawing & Movement
let isDrawing = false;
let flightPathPoints = []; 
let drawingPathPoints = [];
let pathLineMesh = null;
const raycaster = new THREE.Raycaster();
const drawingPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
const mouse = new THREE.Vector2();
let playerTrail = []; 

// DOM
const scoreEl = document.getElementById('score-display');
const healthFillEl = document.getElementById('health-fill');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const finalScoreEl = document.getElementById('final-score');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');

// ==================== INIT ====================
function init() {
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    // FIX: Much lighter fog so enemies are visible at spawn distance
    scene.fog = new THREE.FogExp2(0x050505, 0.0035); 

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 400);
    camera.position.set(0, 20, 35);
    camera.lookAt(0, 0, -10);

    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.getElementById('game-container').appendChild(renderer.domElement);

    // POST PROCESSING (BLOOM)
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0;
    bloomPass.strength = 1.8; // High bloom strength for neon look
    bloomPass.radius = 0.5;

    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // LIGHTING
    // Ambient light for base visibility
    scene.add(new THREE.AmbientLight(0x404040, 2.0)); 
    // Key light
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    // Back light (rim light)
    const backLight = new THREE.DirectionalLight(0x00ffff, 1.0);
    backLight.position.set(-10, 10, -20);
    scene.add(backLight);

    createEnvironment();
    initPathVisualization();

    window.addEventListener('resize', onWindowResize);
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
    document.addEventListener('touchstart', onTouchStart, {passive: false});
    document.addEventListener('touchmove', onTouchMove, {passive: false});
    document.addEventListener('touchend', onMouseUp);

    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);
    startBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); startGame(); }, {passive: false});
    restartBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); startGame(); }, {passive: false});

    initGameObjects();
    animate();
}

function initGameObjects() {
    player = createSciFiShip(CONFIG.colors.playerBody, CONFIG.colors.playerEmissive, CONFIG.colors.playerEngine, false);
    player.position.set(0, 0, 0);
    scene.add(player);
    startScreen.classList.remove('hidden');
}

// ==================== GAME STATE CONTROL ====================
function startGame() {
    startScreen.classList.add('hidden');
    gameOverScreen.classList.add('hidden');
    resetGame();
    isGameRunning = true;
    clock.start();
}

function resetGame() {
    score = 0;
    playerHealth = 100;
    currentSpawnRate = CONFIG.spawnRateBase;
    updateUI();

    enemies.forEach(e => scene.remove(e.mesh));
    bullets.forEach(b => scene.remove(b.mesh));
    particles.forEach(p => scene.remove(p.mesh));
    enemies = [];
    bullets = [];
    particles = [];
    flightPathPoints = [];
    drawingPathPoints = [];
    updatePathVisuals();
    clearTrail();

    player.position.set(0, 0, 0);
    player.rotation.set(0, 0, 0);
    nextSpawnTime = clock.getElapsedTime() + 1.0;
}

function gameOver() {
    isGameRunning = false;
    gameOverScreen.classList.remove('hidden');
    finalScoreEl.innerText = `Score: ${score}`;
    createExplosion(player.position, CONFIG.colors.playerEngine, 50); // Big boom
    player.visible = false; // Hide player momentarily
}

function updateUI() {
    scoreEl.innerText = `SCORE: ${score}`;
    healthFillEl.style.width = `${Math.max(0, playerHealth)}%`;
    if(playerHealth > 50) healthFillEl.style.background = 'linear-gradient(90deg, #ff00ff, #00ffff)';
    else if (playerHealth > 25) healthFillEl.style.background = 'linear-gradient(90deg, #ff9900, #ff3300)';
    else healthFillEl.style.background = 'linear-gradient(90deg, #ff0000, #990000)';
}

// ==================== ENVIRONMENT ====================
function createEnvironment() {
    // Moving Grid
    grid = new THREE.GridHelper(600, 60, CONFIG.colors.grid, 0x1a0033);
    grid.position.y = -5;
    scene.add(grid);

    // Stars
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1000;
    const posArray = new Float32Array(starCount * 3);
    for(let i=0; i<starCount*3; i++) {
        posArray[i] = (Math.random() - 0.5) * 600;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const starMat = new THREE.PointsMaterial({
        color: 0xffffff, size: 0.8, transparent: true, opacity: 0.8
    });
    const stars = new THREE.Points(starGeo, starMat);
    stars.position.z = -100;
    scene.add(stars);
}

function initPathVisualization() {
    const material = new THREE.LineBasicMaterial({
        color: CONFIG.colors.pathLine,
        linewidth: 3,
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending 
    });
    const geometry = new THREE.BufferGeometry();
    pathLineMesh = new THREE.Line(geometry, material);
    pathLineMesh.frustumCulled = false; 
    scene.add(pathLineMesh);
}

function updatePathVisuals() {
    if (drawingPathPoints.length > 1) {
        const pointsArray = new Float32Array(drawingPathPoints.length * 3);
        for (let i = 0; i < drawingPathPoints.length; i++) {
            pointsArray[i * 3] = drawingPathPoints[i].x;
            pointsArray[i * 3 + 1] = drawingPathPoints[i].y;
            pointsArray[i * 3 + 2] = drawingPathPoints[i].z;
        }
        pathLineMesh.geometry.setAttribute('position', new THREE.BufferAttribute(pointsArray, 3));
        pathLineMesh.geometry.attributes.position.needsUpdate = true;
        pathLineMesh.visible = true;
    } else {
        pathLineMesh.visible = false;
    }
}

// ==================== IMPROVED SHIP MODELS ====================
function createSciFiShip(bodyColor, emissiveColor, engineColor, isEnemy) {
    const g = new THREE.Group();
    
    // Use StandardMaterial for reaction to light and bloom
    const matBody = new THREE.MeshStandardMaterial({ 
        color: bodyColor, 
        roughness: 0.4, 
        metalness: 0.8,
        emissive: emissiveColor,
        emissiveIntensity: 0.5
    });

    const matEngine = new THREE.MeshBasicMaterial({ color: engineColor });

    // Main Hull
    const hullGeo = isEnemy 
        ? new THREE.TetrahedronGeometry(1.5, 0) // Spiky enemy
        : new THREE.ConeGeometry(1, 4, 4); // Sleek player
    
    const hull = new THREE.Mesh(hullGeo, matBody);
    
    if(!isEnemy) {
        hull.rotation.x = Math.PI / 2;
        hull.rotation.y = Math.PI / 4; // Rotate for "sharp" edge up
    } else {
        hull.scale.set(1, 1, 2);
    }
    g.add(hull);

    // Glow Engine
    const engGeo = new THREE.SphereGeometry(0.4, 8, 8);
    const eng = new THREE.Mesh(engGeo, matEngine);
    eng.position.z = isEnemy ? 1.5 : 1.8; // Back of ship
    g.add(eng);

    // Add point light to ships so they light up the floor/each other
    const light = new THREE.PointLight(engineColor, 1, 10);
    light.position.set(0, 0, 0);
    g.add(light);

    return g;
}

// ==================== CONTROLS ====================
function getMouseWorldPosition(clientX, clientY) {
    mouse.x = (clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = new THREE.Vector3();
    raycaster.ray.intersectPlane(drawingPlane, intersects);
    return intersects;
}

function onMouseDown(e) {
    if (!isGameRunning || (e.target.tagName === 'BUTTON')) return;
    isDrawing = true;
    flightPathPoints = [];
    drawingPathPoints = []; 
    const pos = getMouseWorldPosition(e.clientX, e.clientY);
    drawingPathPoints.push(player.position.clone());
    drawingPathPoints.push(pos);
    updatePathVisuals();
}

function onMouseMove(e) {
    if (!isGameRunning || !isDrawing) return;
    const pos = getMouseWorldPosition(e.clientX, e.clientY);
    if (drawingPathPoints.length > 0) {
        const lastPoint = drawingPathPoints[drawingPathPoints.length - 1];
        if (pos.distanceTo(lastPoint) > 1.5) { 
            drawingPathPoints.push(pos);
            updatePathVisuals();
        }
    }
}

function onMouseUp() {
    if (!isGameRunning) return;
    isDrawing = false;
    if (drawingPathPoints.length > 1) {
        flightPathPoints = drawingPathPoints.slice(1);
    }
    drawingPathPoints = [];
    updatePathVisuals(); 
}

function onTouchStart(e) {
    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
    if(e.touches.length > 0) {
        onMouseDown(e.touches[0]);
        e.preventDefault(); 
    }
}
function onTouchMove(e) {
    if(e.touches.length > 0) {
        onMouseMove(e.touches[0]);
        e.preventDefault();
    }
}

// ==================== LOGIC ====================
function animate() {
    requestAnimationFrame(animate);
    
    // Always render scene (even if paused, for start screen visuals)
    if (!isGameRunning) {
        player.visible = true; // Ensure visible on start
        composer.render();
        return;
    }

    const time = clock.getElapsedTime();

    // Move Grid
    grid.position.z = (time * 10) % 20;

    updatePlayerMovement();
    updateTrails();
    updateBullets();
    updateEnemies(time);
    updateParticles();
    handleAutoFire(time);

    // Dynamic Camera (Subtle movement)
    camera.position.x += (player.position.x * 0.3 - camera.position.x) * 0.05;

    composer.render();
}

function updatePlayerMovement() {
    player.position.y = Math.sin(clock.elapsedTime * 3) * 0.3; // Idle hover

    if (flightPathPoints.length > 0) {
        const target = flightPathPoints[0];
        const step = CONFIG.playerSpeed;
        const currentPos = player.position.clone();
        const dir = target.clone().sub(currentPos).normalize();
        const dist = currentPos.distanceTo(target);

        if (dist < step) {
             player.position.copy(target);
             flightPathPoints.shift();
        } else {
            player.position.add(dir.multiplyScalar(step));
            
            // Rotation Look
            const lookTarget = player.position.clone().add(dir.clone().multiplyScalar(5));
            const dummy = new THREE.Object3D();
            dummy.position.copy(player.position);
            dummy.lookAt(lookTarget);
            player.quaternion.slerp(dummy.quaternion, 0.1);

            // Banking
            player.rotation.z = -dir.x * 0.8;
        }
        
        if(frameCount % 2 === 0) createTrailSegment(player.position, player.rotation);
    } else {
         player.rotation.z *= 0.9;
         player.rotation.x *= 0.9;
    }
}

let frameCount = 0;

function createTrailSegment(pos, rot) {
    const geo = new THREE.PlaneGeometry(1.5, 0.8);
    const mat = new THREE.MeshBasicMaterial({
        color: CONFIG.colors.playerEngine,
        transparent: true, opacity: 0.8, side: THREE.DoubleSide
    });
    const seg = new THREE.Mesh(geo, mat);
    seg.position.copy(pos);
    seg.rotation.copy(rot);
    seg.rotation.x = Math.PI/2;
    seg.position.z += 1.0; 
    scene.add(seg);
    playerTrail.push({mesh: seg, life: 1.0});
}

function updateTrails() {
    frameCount++;
    for(let i = playerTrail.length - 1; i >= 0; i--) {
        let seg = playerTrail[i];
        seg.life -= 0.05;
        seg.mesh.material.opacity = seg.life;
        seg.mesh.scale.x = seg.life; // Shrink width
        if(seg.life <= 0) {
            scene.remove(seg.mesh);
            playerTrail.splice(i, 1);
        }
    }
}

function clearTrail() {
    playerTrail.forEach(t => scene.remove(t.mesh));
    playerTrail = [];
}

function handleAutoFire(time) {
    if (time * 1000 - lastShootTime > CONFIG.fireRate) {
        shoot();
        lastShootTime = time * 1000;
    }
}

function shoot() {
    const bulletGeo = new THREE.CylinderGeometry(0.1, 0.1, 2);
    // Emissive green for laser look
    const bulletMat = new THREE.MeshBasicMaterial({ color: 0x55ff55 });
    const bullet = new THREE.Mesh(bulletGeo, bulletMat);

    bullet.position.copy(player.position);
    bullet.rotation.copy(player.rotation);
    bullet.rotateX(Math.PI / 2); 
    bullet.position.y += 0.2; 

    const forwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
    bullet.userData.velocity = forwardDir.multiplyScalar(CONFIG.bulletSpeed);

    scene.add(bullet);
    bullets.push({ mesh: bullet });
}


function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.add(b.userData.velocity);
        // Despawn logic
        if (b.mesh.position.z < -200 || b.mesh.position.z > 50 || Math.abs(b.mesh.position.x) > 100) {
            scene.remove(b.mesh);
            bullets.splice(i, 1);
        }
    }
}

function updateEnemies(time) {
    if (time > nextSpawnTime) {
        spawnEnemy();
        nextSpawnTime = time + currentSpawnRate / 1000;
        if (currentSpawnRate > 300) currentSpawnRate -= 10;
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.mesh.position.z += CONFIG.enemySpeed;
        e.mesh.position.x += Math.sin(time * 3 + e.offset) * 0.15; // Wobbly movement
        e.mesh.rotation.z = Math.sin(time * 3 + e.offset) * 0.2; // Banking

        // Player Collision
        if (e.mesh.position.distanceTo(player.position) < 4.0) {
            createExplosion(player.position, CONFIG.colors.playerEngine, 30);
            createExplosion(e.mesh.position, CONFIG.colors.enemyEngine, 30);
            playerHealth -= 35;
            updateUI();
            scene.remove(e.mesh);
            enemies.splice(i, 1);
            if (playerHealth <= 0) gameOver();
            continue;
        }

        // Bullet Collision
        for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            // Simple distance check
            if (b.mesh.position.distanceTo(e.mesh.position) < 4.0) {
                createExplosion(e.mesh.position, CONFIG.colors.enemyEngine, 15);
                scene.remove(b.mesh);
                bullets.splice(j, 1);
                scene.remove(e.mesh);
                enemies.splice(i, 1);
                score += 150;
                updateUI();
                break;
            }
        }

        if (e.mesh.position.z > 30) {
             scene.remove(e.mesh);
             enemies.splice(i, 1);
        }
    }
}

function spawnEnemy() {
    // Enemy is now a "Spike" ship with red glow
    const enemy = createSciFiShip(CONFIG.colors.enemyBody, CONFIG.colors.enemyEmissive, CONFIG.colors.enemyEngine, true);
    enemy.position.set((Math.random()-0.5)*100, 0, -200);
    enemy.rotation.y = Math.PI; 
    enemy.offset = Math.random() * 100; 
    scene.add(enemy);
    enemies.push({ mesh: enemy, offset: enemy.offset });
}

function createExplosion(pos, color, count) {
    for (let i = 0; i < count; i++) {
        const part = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.4, 0.4),
            new THREE.MeshBasicMaterial({ color: color })
        );
        part.position.copy(pos);
        // Random explosion direction
        const vel = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(Math.random()*1.0 + 0.5);
        scene.add(part);
        particles.push({ mesh: part, velocity: vel, life: 1.0 });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= 0.03;
        p.mesh.position.add(p.velocity);
        p.mesh.rotation.x += 0.1;
        p.mesh.scale.setScalar(p.life);
        if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
}

init();

</script>
</body>
</html>
